import * as addPlugin from '@graphql-codegen/add';
import * as typedDocumentNodePlugin from '@graphql-codegen/typed-document-node';
import * as typescriptOperationPlugin from '@graphql-codegen/typescript-operations';
import * as typescriptPlugin from '@graphql-codegen/typescript';
import * as gqlTagPlugin from '@graphql-codegen/gql-tag-operations';
import { processSources } from './process-sources.js';
import { ClientSideBaseVisitor } from '@graphql-codegen/visitor-plugin-common';
import babelOptimizerPlugin from './babel.js';
import * as fragmentMaskingPlugin from './fragment-masking-plugin.js';
const isOutputFolderLike = (baseOutputDir) => baseOutputDir.endsWith('/');
export const preset = {
    prepareDocuments: (outputFilePath, outputSpecificDocuments) => [...outputSpecificDocuments, `!${outputFilePath}`],
    buildGeneratesSection: options => {
        var _a, _b;
        if (!isOutputFolderLike(options.baseOutputDir)) {
            throw new Error('[client-preset] target output should be a directory, ex: "src/gql/"');
        }
        if (options.plugins.length > 0 && Object.keys(options.plugins).some(p => p.startsWith('typescript'))) {
            throw new Error('[client-preset] providing typescript-based `plugins` with `preset: "client" leads to duplicated generated types');
        }
        const reexports = [];
        // the `client` preset is restricting the config options inherited from `typescript`, `typescript-operations` and others.
        const forwardedConfig = {
            scalars: options.config.scalars,
            defaultScalarType: options.config.defaultScalarType,
            strictScalars: options.config.strictScalars,
            namingConvention: options.config.namingConvention,
            useTypeImports: options.config.useTypeImports,
            skipTypename: options.config.skipTypename,
            arrayInputCoercion: options.config.arrayInputCoercion,
            enumsAsTypes: options.config.enumsAsTypes,
            dedupeFragments: options.config.dedupeFragments,
            nonOptionalTypename: options.config.nonOptionalTypename,
            avoidOptionals: options.config.avoidOptionals,
        };
        const visitor = new ClientSideBaseVisitor(options.schemaAst, [], options.config, options.config);
        let fragmentMaskingConfig = null;
        if (typeof ((_a = options === null || options === void 0 ? void 0 : options.presetConfig) === null || _a === void 0 ? void 0 : _a.fragmentMasking) === 'object') {
            fragmentMaskingConfig = options.presetConfig.fragmentMasking;
        }
        else if (((_b = options === null || options === void 0 ? void 0 : options.presetConfig) === null || _b === void 0 ? void 0 : _b.fragmentMasking) !== false) {
            // `true` by default
            fragmentMaskingConfig = {};
        }
        const isMaskingFragments = fragmentMaskingConfig != null;
        const sourcesWithOperations = processSources(options.documents, node => {
            if (node.kind === 'FragmentDefinition') {
                return visitor.getFragmentVariableName(node);
            }
            return visitor.getOperationVariableName(node);
        });
        const sources = sourcesWithOperations.map(({ source }) => source);
        const pluginMap = {
            ...options.pluginMap,
            [`add`]: addPlugin,
            [`typescript`]: typescriptPlugin,
            [`typescript-operations`]: typescriptOperationPlugin,
            [`typed-document-node`]: typedDocumentNodePlugin,
            [`gen-dts`]: gqlTagPlugin,
        };
        const plugins = [
            { [`add`]: { content: `/* eslint-disable */` } },
            { [`typescript`]: {} },
            { [`typescript-operations`]: {} },
            { [`typed-document-node`]: {} },
            ...options.plugins,
        ];
        const genDtsPlugins = [
            { [`add`]: { content: `/* eslint-disable */` } },
            { [`gen-dts`]: { sourcesWithOperations } },
        ];
        const gqlArtifactFileExtension = '.ts';
        reexports.push('gql');
        const config = {
            ...options.config,
            inlineFragmentTypes: isMaskingFragments ? 'mask' : options.config['inlineFragmentTypes'],
        };
        let fragmentMaskingFileGenerateConfig = null;
        if (isMaskingFragments === true) {
            const fragmentMaskingArtifactFileExtension = '.ts';
            reexports.push('fragment-masking');
            fragmentMaskingFileGenerateConfig = {
                filename: `${options.baseOutputDir}fragment-masking${fragmentMaskingArtifactFileExtension}`,
                pluginMap: {
                    [`fragment-masking`]: fragmentMaskingPlugin,
                },
                plugins: [
                    {
                        [`fragment-masking`]: {},
                    },
                ],
                schema: options.schema,
                config: {
                    useTypeImports: options.config.useTypeImports,
                    unmaskFunctionName: fragmentMaskingConfig.unmaskFunctionName,
                },
                documents: [],
            };
        }
        let indexFileGenerateConfig = null;
        const reexportsExtension = options.config.emitLegacyCommonJSImports ? '' : '.js';
        if (reexports.length) {
            indexFileGenerateConfig = {
                filename: `${options.baseOutputDir}index.ts`,
                pluginMap: {
                    [`add`]: addPlugin,
                },
                plugins: [
                    {
                        [`add`]: {
                            content: reexports.map(moduleName => `export * from "./${moduleName}${reexportsExtension}"`).join('\n'),
                        },
                    },
                ],
                schema: options.schema,
                config: {},
                documents: [],
            };
        }
        return [
            {
                filename: `${options.baseOutputDir}graphql.ts`,
                plugins,
                pluginMap,
                schema: options.schema,
                config: {
                    inlineFragmentTypes: isMaskingFragments ? 'mask' : options.config['inlineFragmentTypes'],
                    ...forwardedConfig,
                },
                documents: sources,
            },
            {
                filename: `${options.baseOutputDir}gql${gqlArtifactFileExtension}`,
                plugins: genDtsPlugins,
                pluginMap,
                schema: options.schema,
                config: {
                    ...config,
                    gqlTagName: options.presetConfig.gqlTagName || 'graphql',
                },
                documents: sources,
            },
            ...(fragmentMaskingFileGenerateConfig ? [fragmentMaskingFileGenerateConfig] : []),
            ...(indexFileGenerateConfig ? [indexFileGenerateConfig] : []),
        ];
    },
};
export { babelOptimizerPlugin };
