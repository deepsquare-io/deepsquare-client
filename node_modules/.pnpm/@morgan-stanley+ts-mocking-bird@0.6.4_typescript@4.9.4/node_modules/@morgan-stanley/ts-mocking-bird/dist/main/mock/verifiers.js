"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyFunctionCalled = exports.verifyParameters = exports.createStrictFunctionVerifier = exports.createFunctionVerifier = exports.createFunctionParameterVerifier = void 0;
var helper_1 = require("../helper");
var parameterMatchers_1 = require("./parameterMatchers");
function createFunctionParameterVerifier(mocked, type, functionName) {
    return __assign(__assign({}, createFunctionVerifier(mocked, type, functionName)), { 
        /**
         * withParameters and withParametersEqualTo should have signatures:
         *
         * withParameters: (...parameters: FunctionParameterMatchers<VerifierParams<T, C, U, K>>)
         * withParametersEqualTo: (...parameters: FunctionParameterMatchers<VerifierParams<T, C, U, K>>)
         *
         * but this gives the error: [ts] A rest parameter must be of an array type. [2370]
         * https://github.com/microsoft/TypeScript/issues/29919
         *
         * so we internally type the function as any. This does not affect the extrnal facing function type
         */
        withParameters: (function () {
            var parameters = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                parameters[_i] = arguments[_i];
            }
            return verifyParameters(parameters, mocked, functionName, type, false);
        }), withParametersEqualTo: (function () {
            var parameters = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                parameters[_i] = arguments[_i];
            }
            return verifyParameters(parameters, mocked, functionName, type, true);
        }) });
}
exports.createFunctionParameterVerifier = createFunctionParameterVerifier;
function createFunctionVerifier(mocked, type, functionName, parameterMatchers, strictCallCount) {
    if (strictCallCount === void 0) { strictCallCount = false; }
    return {
        getMock: function () { return mocked; },
        type: type,
        functionName: functionName,
        parameterMatchers: parameterMatchers,
        strictCallCount: strictCallCount,
    };
}
exports.createFunctionVerifier = createFunctionVerifier;
function createStrictFunctionVerifier(mocked, type, functionName, matchers) {
    return __assign(__assign({}, createFunctionVerifier(mocked, type, functionName, matchers)), { strict: function () { return createFunctionVerifier(mocked, type, functionName, matchers, true); } });
}
exports.createStrictFunctionVerifier = createStrictFunctionVerifier;
function verifyParameters(parameters, mocked, functionName, type, equals) {
    var parameterMatchers = parameters.length > 0
        ? parameters.map(function (parameter) { return mapParameterToMatcher(parameter, equals); })
        : undefined;
    return createStrictFunctionVerifier(mocked, type, functionName, parameterMatchers);
}
exports.verifyParameters = verifyParameters;
function mapParameterToMatcher(param, equals) {
    if (parameterMatchers_1.isParameterMatcher(param)) {
        return param;
    }
    if (typeof param === 'function') {
        return param;
    }
    return equals ? parameterMatchers_1.toEqual(param) : parameterMatchers_1.toBe(param);
}
function verifyFunctionCalled(times, verifier) {
    var mock = verifier.getMock();
    var type = verifier.type;
    var functionName = verifier.functionName;
    var parameterMatchers = verifier.parameterMatchers;
    var strict = verifier.strictCallCount;
    var expectationMessage;
    var errorMessageSetupFunction;
    var errorMessageDescription;
    var functionCalls = helper_1.getLookup(mock, type)[functionName];
    switch (type) {
        case 'staticGetter':
            expectationMessage = "Expected static property \"" + functionName + "\" getter to be called";
            errorMessageSetupFunction = "Mock.setupStaticProperty()";
            errorMessageDescription = "Static property";
            break;
        case 'staticSetter':
            expectationMessage = "Expected static property \"" + functionName + "\" to be set";
            errorMessageSetupFunction = "Mock.setupStaticProperty()";
            errorMessageDescription = "Static property";
            break;
        case 'staticFunction':
            expectationMessage = "Expected static function \"" + functionName + "\" to be called";
            errorMessageSetupFunction = "Mock.setupStaticFunction()";
            errorMessageDescription = "Static function";
            break;
        case 'getter':
            expectationMessage = "Expected property \"" + functionName + "\" getter to be called";
            errorMessageSetupFunction = "Mock.setupProperty()";
            errorMessageDescription = "Property";
            break;
        case 'setter':
            expectationMessage = "Expected property \"" + functionName + "\" to be set";
            errorMessageSetupFunction = "Mock.setupProperty()";
            errorMessageDescription = "Property";
            break;
        default:
            expectationMessage = "Expected \"" + functionName + "\" to be called";
            errorMessageSetupFunction = "Mock.setupFunction()";
            errorMessageDescription = "Function";
    }
    if (functionCalls === undefined) {
        return createCustomMatcherFailResult(errorMessageDescription + " \"" + functionName + "\" has not been setup. Please setup using " + errorMessageSetupFunction + " before verifying calls.");
    }
    var parameterMatchResults = functionCalls.map(function (params) { return matchParameters(params, parameterMatchers); });
    var customMatcherResults = parameterMatchResults.filter(isMatcherResultArray);
    if (customMatcherResults.length > 0) {
        return customMatcherResults[0][0];
    }
    var matchingCalls = parameterMatchResults.filter(function (paramMatch) { return paramMatch === true; });
    if (times !== undefined) {
        if (times !== matchingCalls.length || (strict && times !== functionCalls.length)) {
            return createCustomMatcherFailResult(expectationMessage + " " + times + " times " + buildWithParamsString(parameterMatchers, strict) + "but it was called " + matchingCalls.length + " times with matching parameters and " + functionCalls.length + " times in total." + buildAllCallsString(functionCalls, parameterMatchers));
        }
    }
    else {
        if (matchingCalls.length === 0) {
            var calledWithMessage = void 0;
            if (functionCalls.length > 0) {
                calledWithMessage = "it was only called with these parameters:" + buildAllCallsString(functionCalls, parameterMatchers);
            }
            else {
                calledWithMessage = "it was not.";
            }
            return createCustomMatcherFailResult(expectationMessage + " " + buildWithParamsString(parameterMatchers, strict) + "but " + calledWithMessage);
        }
    }
    return { pass: true };
}
exports.verifyFunctionCalled = verifyFunctionCalled;
function createCustomMatcherFailResult(message) {
    if (helper_1.runningInJest()) {
        return {
            pass: false,
            message: function () { return message; },
        };
    }
    return {
        pass: false,
        message: message,
    };
}
function buildWithParamsString(parameterMatchers, strict) {
    var withParamsMessage;
    if (Array.isArray(parameterMatchers) && parameterMatchers.length > 0) {
        withParamsMessage = "with params [" + expectedParametersToString(parameterMatchers) + "] ";
        if (strict) {
            withParamsMessage = withParamsMessage + "and 0 times with any other parameters ";
        }
    }
    else {
        withParamsMessage = '';
    }
    return withParamsMessage;
}
function buildAllCallsString(functionCalls, parameterMatchers) {
    var allCalls;
    if (functionCalls.some(function (call) { return call.length > 0; })) {
        allCalls = "\n[\n" + functionCalls.map(function (call) { return functionCallToString(call, parameterMatchers); }).join('\n') + "\n]";
    }
    else {
        allCalls = '';
    }
    return allCalls;
}
function expectedParametersToString(parameterMatchers) {
    return parameterMatchers
        .map(function (matcher) {
        return parameterMatchers_1.isParameterMatcher(matcher) ? matcher.expectedDisplayValue : '<customParameterMatchFunction>';
    })
        .join(', ');
}
function functionCallToString(call, parameterMatchers) {
    var params = call
        .map(function (callParam, index) {
        var matcher = parameterMatchers ? parameterMatchers[index] : undefined;
        if (parameterMatchers_1.isParameterMatcher(matcher) && matcher.parameterToString != null) {
            return "<" + matcher.parameterToString(callParam) + ">";
        }
        return parameterMatchers_1.mapItemToString(callParam);
    })
        .join(',');
    return "[" + params + "]";
}
function isMatcherResultArray(paramResult) {
    if (Array.isArray(paramResult)) {
        return paramResult.every(isMatcherResult);
    }
    return false;
}
function isMatcherResult(paramResult) {
    if (Array.isArray(paramResult)) {
        return paramResult.every(isMatcherResult);
    }
    return typeof paramResult !== 'boolean';
}
function matchParameters(actualParameters, parameterMatchers) {
    if (parameterMatchers == null) {
        return true;
    }
    if (actualParameters.length !== parameterMatchers.length) {
        return false;
    }
    var evaluatedParams = parameterMatchers.map(function (matcher, index) {
        return evaluateParameterMatcher(actualParameters[index], matcher);
    });
    var matcherResults = evaluatedParams.filter(isMatcherResult);
    return matcherResults.length > 0 ? matcherResults : evaluatedParams.every(function (param) { return param === true; });
}
function evaluateParameterMatcher(actualParam, matcher) {
    if (typeof matcher === 'function') {
        var matcherReturnValue = void 0;
        try {
            matcherReturnValue = matcher(actualParam);
        }
        catch (e) {
            return createCustomMatcherFailResult("Error: calling custom parameter match function threw an error (" + e + ") rather returning a boolean. You must use an existing IParameterMatcher (such as toBe(value)) or implement your own if you want to verify functions passed as mocked function arguments.");
        }
        if (typeof matcherReturnValue !== 'boolean') {
            return createCustomMatcherFailResult("Error calling custom parameter match function. Function returned \"" + matcherReturnValue + "\" (typeof: " + typeof matcherReturnValue + ") rather than a boolean. You must use an existing IParameterMatcher (such as toBe(value)) or implement your own if you want to verify functions passed as mocked function arguments.");
        }
        return matcherReturnValue;
    }
    else {
        return matcher.isExpectedValue(actualParam);
    }
}
//# sourceMappingURL=verifiers.js.map