import { ConstructorFunction, FunctionName, FunctionParams, IFunctionVerifier, IFunctionWithParametersVerification, IJasmineCustomMatcherResult, IJestCustomMatcherResult, IMocked, IStrictFunctionVerification, LookupType, ParameterMatcher, SetterTypes, VerifierTarget } from './contracts';
export declare type VerifierParams<T, C extends ConstructorFunction<T>, U extends LookupType, K extends FunctionName<T, C, U>> = U extends SetterTypes ? [VerifierTarget<T, C, U>[K]] : FunctionParams<VerifierTarget<T, C, U>[K]>;
export declare function createFunctionParameterVerifier<T, C extends ConstructorFunction<T>, U extends LookupType, K extends FunctionName<T, C, U>>(mocked: IMocked<T, C>, type: U, functionName: K): IFunctionWithParametersVerification<VerifierParams<T, C, U, K>, T, U, C>;
export declare function createFunctionVerifier<T, C extends ConstructorFunction<T>, U extends LookupType, K extends FunctionName<T, C, U>>(mocked: IMocked<T, C>, type: U, functionName: K, parameterMatchers?: ParameterMatcher<any>[], strictCallCount?: boolean): IFunctionVerifier<T, U, C>;
export declare function createStrictFunctionVerifier<T, C extends ConstructorFunction<T>, U extends LookupType, K extends FunctionName<T, C, U>>(mocked: IMocked<T, C>, type: U, functionName: K, matchers?: ParameterMatcher<any>[]): IStrictFunctionVerification<T, U, C>;
export declare function verifyParameters<T, C extends ConstructorFunction<T>, U extends LookupType, K extends FunctionName<T, C, U>>(parameters: ParameterMatcher<any>[], mocked: IMocked<T, C>, functionName: K, type: U, equals: boolean): IStrictFunctionVerification<T, U, C>;
export declare function verifyFunctionCalled<T, C extends ConstructorFunction<T>, U extends LookupType>(times: number | undefined, verifier: IFunctionVerifier<T, U, C>): IJasmineCustomMatcherResult | IJestCustomMatcherResult;
