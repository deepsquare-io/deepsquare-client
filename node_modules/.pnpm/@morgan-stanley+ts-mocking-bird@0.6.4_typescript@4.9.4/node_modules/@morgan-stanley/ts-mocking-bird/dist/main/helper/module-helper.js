"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reset = exports.registerMock = exports.proxyModule = exports.isWrappedModule = void 0;
var uuid_1 = require("uuid");
function isWrappedModule(value) {
    return value != null && typeof value.___moduleId === 'string';
}
exports.isWrappedModule = isWrappedModule;
var MockMap = new Map();
/**
 * Takes an existing function and wraps all functions and constructors.
 * This allows us to replace the function or constructor after it has been imported into the system under test
 * This will not replace statics on classes or replace constant values in the module
 * @param originalModule
 */
function proxyModule(originalModule) {
    var wrappedModule = { ___moduleId: uuid_1.v4() };
    Object.keys(originalModule).forEach(function (key) {
        var originalValue = originalModule[key];
        wrappedModule[key] =
            typeof originalValue === 'function' ? wrapFunction(wrappedModule, key, originalValue) : originalValue;
    });
    return wrappedModule;
}
exports.proxyModule = proxyModule;
/**
 * Replaces functions or constructors in a previously wrapped module.
 * If a module is not wrapped a warning is logged and no replacements occur
 * @param moduleProxy
 * @param mock
 */
function registerMock(moduleProxy, mock) {
    if (!isWrappedModule(moduleProxy)) {
        console.warn("Not registering mock as supplied module is not a wrapped module");
        return;
    }
    var mocks = lookupMocksForModule(moduleProxy);
    mocks.push(mock);
}
exports.registerMock = registerMock;
/**
 * Replaces previously replaced module members
 * @param moduleProxy
 */
function reset(moduleProxy) {
    if (!isWrappedModule(moduleProxy)) {
        return;
    }
    MockMap.set(moduleProxy.___moduleId, undefined);
}
exports.reset = reset;
function lookupMocksForModule(originalModule) {
    var mocks = MockMap.get(originalModule.___moduleId);
    if (mocks === undefined) {
        mocks = [];
        MockMap.set(originalModule.___moduleId, mocks);
    }
    return mocks;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function wrapFunction(mockModule, key, func) {
    function wrapped() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var returnFunc = getMocked(mockModule, key) || func;
        return returnFunc.apply(this, args);
    }
    wrapped.prototype = func.prototype;
    return wrapped;
}
function getMocked(mockModule, key) {
    var mocks = lookupMocksForModule(mockModule);
    for (var index = 0; index < mocks.length; index++) {
        var mock = mocks[index];
        if (typeof mock[key] === 'function') {
            return mock[key];
        }
    }
    return undefined;
}
//# sourceMappingURL=module-helper.js.map