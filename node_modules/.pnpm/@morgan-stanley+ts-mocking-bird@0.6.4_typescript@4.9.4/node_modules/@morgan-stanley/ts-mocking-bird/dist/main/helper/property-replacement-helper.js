"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockImportsBeforeEach = exports.replacePropertiesBeforeEach = exports.mockImports = exports.replaceProperties = void 0;
/* eslint-disable @typescript-eslint/ban-types */
/**
 * This is hacky and should never be done in non-test code
 * We need to do this as webpack builds immutable export objects that uses Object.defineProperty with configurable set to false
 * This means we are unable to replace the imports at runtime and mock them.
 */
(function (defineProperty) {
    Object.defineProperty = function (obj, prop, desc) {
        if (prop === 'prototype' && typeof obj === 'function') {
            // do not make class prototype properties writable
            // if we try to do this things blow up in ng 13 (babel and zone.js)
            return defineProperty(obj, prop, desc);
        }
        desc.configurable = true;
        return defineProperty(obj, prop, desc);
    };
})(Object.defineProperty);
/**
 * Replaces properties (or functions) in the provided object
 * Replacement is done in a call to 'beforeAll'.
 * Properties are reverted to the original value in a call to 'afterAll'
 *
 * @param target The original object. Could be an import: 'import * as myImport from "./importLocation"'
 * @param mocks Object containing functions or properties to replace
 */
function replaceProperties(target, mocks) {
    var descriptors = getDescriptors(target, mocks);
    beforeAll(function () {
        replaceImports(mocks, target);
    });
    afterAll(function () {
        revertImports(target, descriptors);
    });
}
exports.replaceProperties = replaceProperties;
exports.mockImports = replaceProperties;
/**
 * Replaces functions, classes or simple values in objects.
 * This runs before each test allowing us to create a new mock object before each test and assert function calls
 *
 * Example:
 *
 * // SUT:
 * import { sampleFunction, SampleClass} from "someImport";
 *
 * export MyClass{
 *      public getValue(){
 *          return new SampleClass();
 *      }
 *
 *      public getOtherValue(){
 *          return sampleFunction();
 *      }
 * }
 *
 * // Test:
 *
 * describe("test", () => {
 *
 * import * as importToMock from "someImport";
 *
 * replacePropertiesBeforeEach(() => {
 *  const mockedClass = Mock.create<SampleClass>().setupFunction("getValue");
 *  const mockedFunction = () => "mockedValue";
 *
 *  return [{package: importToMock, mocks: {SampleClass: mockedClass.mockConstructor, sampleFunction: mockedFunction}}];
 * });
 *
 * })
 *
 * @param callback a function used to setup your mocks and to return an array of import replacements
 */
function replacePropertiesBeforeEach(callback) {
    var importCopies = [];
    beforeEach(function () {
        var mockedImports = callback();
        mockedImports.forEach(function (importReplacement) {
            importCopies.push({
                packageWithReplacements: importReplacement.package,
                descriptors: getDescriptors(importReplacement.package, importReplacement.mocks),
            });
            replaceImports(importReplacement.mocks, importReplacement.package);
        });
    });
    afterEach(function () {
        importCopies.forEach(function (copy) { return revertImports(copy.packageWithReplacements, copy.descriptors); });
    });
}
exports.replacePropertiesBeforeEach = replacePropertiesBeforeEach;
exports.mockImportsBeforeEach = replacePropertiesBeforeEach;
function getDescriptors(original, mocks) {
    var descriptors = {};
    for (var key in mocks) {
        if (mocks[key] != null) {
            descriptors[key] = getDescriptor(original, key);
        }
    }
    return descriptors;
}
function getDescriptor(target, key) {
    if (target == null) {
        throw Error("Could not resolve property descriptor " + key);
    }
    var descriptor = Object.getOwnPropertyDescriptor(target, key);
    if (descriptor == null) {
        return getDescriptor(target.__proto__, key);
    }
    return descriptor;
}
function replaceImports(mocks, originalPackage) {
    for (var importName in mocks) {
        if (mocks[importName] != null) {
            var mockDescriptor = getDescriptor(mocks, importName);
            try {
                Object.defineProperty(originalPackage, importName, mockDescriptor);
            }
            catch (e) {
                throw new Error("Error when trying to mock import '" + importName + "':\n" + e + "\nPlease see readme about likely cause and ways to resolve");
            }
        }
    }
}
function revertImports(packageWithReplacements, descriptors) {
    for (var key in descriptors) {
        if (descriptors[key] != null) {
            Object.defineProperty(packageWithReplacements, key, descriptors[key]);
        }
    }
}
//# sourceMappingURL=property-replacement-helper.js.map