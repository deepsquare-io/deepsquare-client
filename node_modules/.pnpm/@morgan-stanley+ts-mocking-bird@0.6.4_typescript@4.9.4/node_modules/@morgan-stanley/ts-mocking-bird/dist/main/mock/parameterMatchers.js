"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapItemToString = exports.any = exports.toEqual = exports.toBe = exports.hasValue = exports.toBeDefined = exports.isParameterMatcher = void 0;
var lodash_1 = require("lodash");
function isParameterMatcher(matcher) {
    var typedMatcher = matcher;
    return (matcher != null &&
        typeof typedMatcher.expectedDisplayValue === 'string' &&
        typeof typedMatcher.isExpectedValue === 'function');
}
exports.isParameterMatcher = isParameterMatcher;
/**
 * Checks that the value is not undefined.
 * This will pass if the value is null (like jasmine does).
 * actualValue !== undefined
 */
function toBeDefined() {
    return {
        isExpectedValue: function (actualValue) { return actualValue !== undefined; },
        expectedDisplayValue: '<mustBeDefined>',
    };
}
exports.toBeDefined = toBeDefined;
/**
 * Checks that the value is not undefined and not null.
 * actualValue != null
 */
function hasValue() {
    return {
        isExpectedValue: function (actualValue) { return actualValue != null; },
        expectedDisplayValue: '<hasValue>',
    };
}
exports.hasValue = hasValue;
/**
 * Compares the expected value to the actual value with a strict equality check.
 * actualValue === expectedValue
 *
 * @param expectedValue
 */
function toBe(expectedValue) {
    return {
        expectedDisplayValue: mapItemToString(expectedValue),
        isExpectedValue: function (actualValue) { return actualValue === expectedValue; },
    };
}
exports.toBe = toBe;
/**
 * Checks that the expected value is equal to the actual value using deep object comparison.
 * actualValue => isEqual(actualValue, expectedValue)
 *
 * @param expectedValue
 */
function toEqual(expectedValue) {
    return {
        expectedDisplayValue: mapItemToString(expectedValue),
        isExpectedValue: function (actualValue) { return lodash_1.isEqual(actualValue, expectedValue); },
    };
}
exports.toEqual = toEqual;
/**
 * Allows any value.
 */
function any() {
    return {
        expectedDisplayValue: "<matchAny>",
        isExpectedValue: function () { return true; },
    };
}
exports.any = any;
/**
 * Returns a string representation of a value.
 * @param item
 */
function mapItemToString(item) {
    if (typeof item === 'string') {
        return "\"" + item + "\"";
    }
    if (item === undefined) {
        return 'undefined';
    }
    return JSON.stringify(item, replaceValue).replace(ReplaceUndefinedRegExp, 'undefined');
}
exports.mapItemToString = mapItemToString;
// https://regex101.com/r/BIvQJG/2
var functionStringRegExp = /function\s*\([^)]*\)/;
/**
 * string value that is VERY unlikely to be a genuine value
 */
var UndefinedReplacementString = "___@morgan-stanley/ts-mocking-bird_undefined_@morgan-stanley/ts-mocking-bird___";
var ReplaceUndefinedRegExp = new RegExp("\"" + UndefinedReplacementString + "\"", 'g');
function replaceValue(_key, value) {
    switch (typeof value) {
        case 'function':
            // eslint-disable-next-line no-case-declarations
            var functionString = String(value);
            // eslint-disable-next-line no-case-declarations
            var regexpResult = functionStringRegExp.exec(functionString);
            return regexpResult != null ? regexpResult[0] : 'FUNCTION_BODY_REMOVED';
        case 'undefined':
            return UndefinedReplacementString;
    }
    return value;
}
//# sourceMappingURL=parameterMatchers.js.map