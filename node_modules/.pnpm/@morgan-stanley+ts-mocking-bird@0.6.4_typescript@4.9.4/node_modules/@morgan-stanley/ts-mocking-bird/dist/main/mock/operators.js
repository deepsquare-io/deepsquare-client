"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStaticProperty = exports.defineProperty = exports.setupStaticProperty = exports.setupProperty = exports.setupStaticFunction = exports.setupFunction = void 0;
/* eslint-disable no-case-declarations */
var helper_1 = require("../helper");
/**
 * Mocks a function on an existing Mock.
 * Allows function call verification to be performed later in the test.
 * You can optionally set a mock function implementation that will be called.
 *
 * @param functionName
 * @param mockFunction
 */
function setupFunction(functionName, mockFunction) {
    return function (mocked) {
        var _a;
        var functionReplacement = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var returnValue;
            var mockedFunction = (_a = mocked.functionReplacementLookup['function']) === null || _a === void 0 ? void 0 : _a[functionName];
            if (mockedFunction instanceof Function) {
                returnValue = mockedFunction.apply(mocked.mock, args);
            }
            trackFunctionCall(mocked, 'function', functionName, args);
            return returnValue;
        };
        var functionLookup = (mocked.functionReplacementLookup['function'] =
            mocked.functionReplacementLookup['function'] || {});
        functionLookup[functionName] = mockFunction;
        // we do not replace an existing function in case it has already been destructured and sut already has a reference to it
        // we do replace the mocked implementation above though
        // eslint-disable-next-line @typescript-eslint/ban-types
        if (((_a = mocked.mock[functionName]) === null || _a === void 0 ? void 0 : _a.name) != functionReplacement.name) {
            mocked.mock[functionName] = functionReplacement;
        }
        mocked.functionCallLookup[functionName] = [];
        return mocked;
    };
}
exports.setupFunction = setupFunction;
/**
 * Mocks a static function on an existing Mock.
 * Allows function call verification to be performed later in the test.
 * You can optionally set a mock function implementation that will be called.
 *
 * @param functionName
 * @param mockFunction
 */
function setupStaticFunction(functionName, mockFunction) {
    return function (mocked) {
        var _a;
        var functionReplacement = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var returnValue;
            var mockedFunction = (_a = mocked.functionReplacementLookup['staticFunction']) === null || _a === void 0 ? void 0 : _a[functionName];
            if (mockedFunction instanceof Function) {
                returnValue = mockedFunction.apply(mocked.mock, args);
            }
            trackFunctionCall(mocked, 'staticFunction', functionName, args);
            return returnValue;
        };
        var staticFunctionLookup = (mocked.functionReplacementLookup['staticFunction'] =
            mocked.functionReplacementLookup['staticFunction'] || {});
        staticFunctionLookup[functionName] = mockFunction;
        // eslint-disable-next-line @typescript-eslint/ban-types
        if (((_a = mocked.mockConstructor[functionName]) === null || _a === void 0 ? void 0 : _a.name) != functionReplacement.name) {
            mocked.mockConstructor[functionName] = functionReplacement;
        }
        mocked.staticFunctionCallLookup[functionName] = [];
        return mocked;
    };
}
exports.setupStaticFunction = setupStaticFunction;
/**
 * Sets up a property on an existing Mock.
 * Allows the value of the property to be defined.
 * Enables get and set function call verification to be performed.
 *
 * @param propertyName
 * @param value
 */
function setupProperty(propertyName, value) {
    return defineProperty(propertyName, value !== undefined ? function () { return value; } : undefined);
}
exports.setupProperty = setupProperty;
/**
 * Sets up a static property on an existing Mock.
 * Allows the value of the property to be defined.
 * Enables get and set function call verification to be performed.
 *
 * @param propertyName
 * @param value
 */
function setupStaticProperty(propertyName, value) {
    return defineStaticProperty(propertyName, value !== undefined ? function () { return value; } : undefined);
}
exports.setupStaticProperty = setupStaticProperty;
/**
 * Sets up a property on an existing Mock.
 * Allows getter and setter functions to be set.
 * Enables get and set function call verification to be performed.
 *
 * @param propertyName
 * @param value
 */
function defineProperty(propertyName, getter, setter) {
    return function (mocked) {
        return definePropertyImpl(mocked, 'getter', propertyName, getter, setter);
    };
}
exports.defineProperty = defineProperty;
/**
 * Sets up a static property on an existing Mock with constructor.
 * Allows getter and setter functions to be set.
 * Enables get and set function call verification to be performed.
 *
 * @param propertyName
 * @param value
 */
function defineStaticProperty(propertyName, getter, setter) {
    return function (mocked) {
        return definePropertyImpl(mocked, 'staticGetter', propertyName, getter, setter);
    };
}
exports.defineStaticProperty = defineStaticProperty;
function definePropertyImpl(mocked, lookupType, propertyName, getter, setter) {
    var propertyGetter = function () {
        var _a;
        trackGetterCall(mocked, lookupType, propertyName);
        var mockedFunction = (_a = mocked.functionReplacementLookup[lookupType]) === null || _a === void 0 ? void 0 : _a[propertyName];
        return mockedFunction ? mockedFunction() : undefined;
    };
    var setterLookupType;
    switch (lookupType) {
        case 'getter':
            setterLookupType = 'setter';
            var getterLookup = (mocked.functionReplacementLookup['getter'] =
                mocked.functionReplacementLookup['getter'] || {});
            getterLookup[propertyName] = getter;
            var setterLookup = (mocked.functionReplacementLookup['setter'] =
                mocked.functionReplacementLookup['setter'] || {});
            setterLookup[propertyName] = setter;
            break;
        case 'staticGetter':
            var staticGetterLookup = (mocked.functionReplacementLookup['staticGetter'] =
                mocked.functionReplacementLookup['staticGetter'] || {});
            staticGetterLookup[propertyName] = getter;
            var staticSetterLookup = (mocked.functionReplacementLookup['staticSetter'] =
                mocked.functionReplacementLookup['staticSetter'] || {});
            staticSetterLookup[propertyName] = setter;
            setterLookupType = 'staticSetter';
            break;
    }
    var setterProperty = propertyName;
    var propertySetter = function (value) {
        var _a;
        trackSetterCall(mocked, setterLookupType, setterProperty, [value]);
        var mockedFunction = (_a = mocked.functionReplacementLookup[setterLookupType]) === null || _a === void 0 ? void 0 : _a[propertyName];
        if (mockedFunction != null) {
            mockedFunction.apply(mocked.mock, [value]);
        }
    };
    var target;
    helper_1.getLookup(mocked, lookupType)[propertyName] = [];
    switch (lookupType) {
        case 'staticGetter':
            target = mocked.mockConstructor;
            helper_1.getLookup(mocked, 'staticSetter')[setterProperty] = [];
            break;
        default:
            target = mocked.mock;
            helper_1.getLookup(mocked, 'setter')[setterProperty] = [];
            break;
    }
    if (Object.getOwnPropertyDescriptor(target, propertyName) == null) {
        Object.defineProperty(target, propertyName, {
            enumerable: true,
            get: propertyGetter,
            set: propertySetter,
            configurable: true,
        });
    }
    return mocked;
}
function trackFunctionCall(mock, lookupType, functionName, params) {
    var lookup = helper_1.getLookup(mock, lookupType);
    trackCall(lookup, functionName, params);
}
function trackGetterCall(mock, lookupType, propertyName) {
    var lookup = helper_1.getLookup(mock, lookupType);
    //  it's easier to have an array of empty arrays than just keep track of a count
    //  This allows us to use the same verification code as the setter and functions
    trackCall(lookup, propertyName, []);
}
function trackSetterCall(mock, lookupType, propertyName, param) {
    var lookup = helper_1.getLookup(mock, lookupType);
    trackCall(lookup, propertyName, param);
}
function trackCall(lookup, name, params) {
    var functionCalls = lookup[name];
    if (functionCalls === undefined) {
        functionCalls = [];
        lookup[name] = functionCalls;
    }
    functionCalls.push(params);
}
//# sourceMappingURL=operators.js.map